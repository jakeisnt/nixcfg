#!/usr/bin/env nix-shell
#! nix-shell -p babashka -i "bb -i"

(ns hey
  (:require [clojure.tools.cli :refer [parse-opts]]
            [babashka.process :as p]
            [clojure.core.match :refer [match]]
            [clojure.java.io :as io]))

(def flake "/etc/nixos")

(def cli-options
  [["f" "find PACKNAME" "Package name to search for"]
   ["r" "rebuild" "Rebuild the current NixOS image without upgrading"]
   ["u" "upgrade" "Upgrade and rebuild the NixOS image with new, upgraded inputs"]
   ["-h" "--help"]])

;; rum a command with a custom printer and sane defaults provided to the process
(defn cmd [args & [settings]]
  (let
    [proc (p/process args (merge {:out :inherit :err :inherit :shutdown p/destroy-tree} (or settings nil)))]
    (with-open [rdr (io/reader (:out proc))]
      (binding [*in* rdr]
        @proc
        nil))))

;; find a nixpkgs package available
(defn find [packname]
  (cmd ["nix" "search" "nixpkgs" packname]))

;; update the provided flake
(defn update [flake]
  (cmd ["nix" "flake" "update" flake "--impure"]))

;; rebuild and switch to the system
(defn rebuild [flake]
  (cmd
    ["sudo" "nixos-rebuild" "switch"
     "--flake" flake
     "--option" "pure-eval" "no"]
    {:in :inherit :out :inherit}))

(defn upgrade [flake]
  (do
    (update flake)
    (rebuild flake)))

(defn main [args]
  (let
    [res (parse-opts args cli-options)
     opts (:options res)
     args (:arguments res)]

    (match args
           ["find" packname] (find packname)
           ["rebuild"] (rebuild flake)
           ["update"] (update flake)
           ["upgrade"] (upgrade flake)
           :else (println "Commands provided were invalid - sorry!"))))

(main *command-line-args*)

;; vi: ft=clojure
